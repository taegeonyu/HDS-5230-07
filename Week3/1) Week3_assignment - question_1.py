# -*- coding: utf-8 -*-
"""Week3_assignment - question 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tRc40WKq5fylosupuHOa6IhPRM6-UruH
"""

# import necessary libraries
import time
import pandas as pd
import numpy as np
from math import *
import cProfile

"""## Overview of the Data"""

# check the dataset
df = pd.read_excel('/content/clinics.xls')
df.head()

df.shape

df.info()

"""* There are over 20 varibles but we only need the latitude and longitude.
* The location column (state) may also be helpful.
"""

# subset data with necessary columns
df = df[['bizState', 'locLat', 'locLong']]
df = df.rename(columns = {'bizState': 'state', 'locLat':'latitude', 'locLong':'longitude'})
df.sample(8, random_state =1)

"""* The data is successfully subsetted with the necessary varaibles.

## Haversine Function
"""

# define the distance computation function
def haversine(lat1, lon1, lat2, lon2):
    MILES = 3959
    lat1, lon1, lat2, lon2 = map(np.deg2rad, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
    c = 2 * np.arcsin(np.sqrt(a))
    total_miles = MILES * c
    return total_miles

"""* The harversine function is created and needs to be applied to various computation methods.

## Applying the Harversine Function
"""

# Commented out IPython magic to ensure Python compatibility.
# # basic for-loop
# %%timeit
# for i in range(len(df)):
#     haversine(40.671, -73.985, df.iloc[i]['latitude'], df.iloc[i]['longitude'])

# Commented out IPython magic to ensure Python compatibility.
# # vectorize code by using iterrows
# %%timeit
# haversine_series = []
# for index, row in df.iterrows():
#     haversine_series.append(haversine(40.671, -73.985, row['latitude'], row['longitude']))
# df['distance'] = haversine_series

# Commented out IPython magic to ensure Python compatibility.
# # optimize further using apply()
# %%timeit
# df['distance'] = df.apply(lambda row: haversine(40.671, -73.985, row['latitude'], row['longitude']), axis=1)
# 
# # profile execution with cProfile
# """
# cProfile.run("df['distance'] = df.apply(lambda row: haversine(40.671, -73.985, row['latitude'], row['longitude']), axis=1)")
# """

# Commented out IPython magic to ensure Python compatibility.
# # vectorized implementation of haversine using pandas
# %%timeit
# df['distance'] = haversine(40.671, -73.985, df['latitude'], df['longitude'])
# 
# # profile execution time
# """
# cProfile.run("df['distance'] = haversine(40.671, -73.985, df['latitude'], df['longitude'])")
# """

# Commented out IPython magic to ensure Python compatibility.
# # vectorized implementation of Haversine using NumPy
# %%timeit
# df['distance'] = haversine(40.671, -73.985, df['latitude'].values, df['longitude'].values)
# 
# # profile execution time
# """
# cProfile.run("df['distance'] = haversine(40.671, -73.985, df['latitude'].values, df['longitude'].values)")
# """

"""* The results for 5 methods are computed and needs comparison.

## Comparing the Results
"""

execute_times = {
    'for loop': '5.51 ms ± 730 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)',
    'iterrows': '5.15 ms ± 1.51 ms per loop (mean ± std. dev. of 7 runs, 100 loops each))',
    'apply': '1.19 ms ± 221 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)',
    'vec_implement_pandas': '1.37 ms ± 257 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)',
    'vec_implement_numpy': '226 µs ± 92.5 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)'
}

for k, v in execute_times.items():
    print(f"{k}: {v}")

"""* DataFrame will be a better choice for visual display."""

# dictionary to set up for dataframe
execute_times = {
    'Method': ['For Loop', 'iterrows', 'apply', 'Vectorized Pandas', 'Vectorized NumPy'],
    'Execution Time (ms)': [5.51, 5.15, 1.19, 1.37, 0.226]
}

# dataframe for better visibility
df_exec_times = pd.DataFrame(execute_times)
df_exec_times

"""* The computated times are tabulated.

## Conclusion

* For-Loop: Commonly used for ordinary taks on small data, but not recommend for large datasets.
* Iterrows: Slightly faster than for-loop but not recommended as well, row by row application causing high overhead.
* Apply: Faster than iterrows and for loop with big improvement.
* Vectorized Pandas: Slightly slower than apply function, but still shows great improvement compared to iterrows and for-loop.
* Vectorized Numpy: The fastest method with most effiicient computation.
"""
